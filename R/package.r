#' Build complete static documentation for a package.
#'
#' @param package name of package (as character string) to create
#'   documentation for
#' @param base_path root directory in which to create documentation
#' @param examples include examples or not?  Examples are particularly
#'   slow to render because all code must be run, so turning them off makes
#'   it easier to tweak templates etc.
#' @export
#' @import stringr
#' @aliases staticdocs-package
build_package <- function(package, base_path, examples = TRUE) {
  if (!file.exists(base_path)) dir.create(base_path)
  copy_bootstrap(base_path)

  info <- package_info(package)
  index <- topic_index(package)

  info$topics <- build_topics(package, base_path, info, examples = examples, index = index)
  info$vignettes <- build_vignettes(package, base_path)
  info$demos <- build_demos(package, base_path, info, index)
  info$readme <- readme(package)
  
  message("Generating index.html")
  render_template("index", info, file.path(base_path, "index.html"))
  
  if (interactive()) {
    browseURL(normalizePath(file.path(base_path, "index.html")))
  }
  invisible(TRUE)
}

#' Generate all topic pages for a package.
#'
#' @export
#' @inheritParams build_package
#' @param package_info A list containing information about the package,
#'   as generated by \code{\link{package_info}}
build_topics <- function(package, base_path, package_info, index, examples = TRUE) {
  package <- as.package(package)

  # for each file, find name of one topic
  topics <- index$alias[!duplicated(index$file_in)]
  files_in <- index$file_in[!duplicated(index$file_in)]
  files_out <- index$file_out[!duplicated(index$file_in)]
  paths <- file.path(base_path, files_out)

  # create columns for extra topic info
  index$title <- ""
  index$class <- NA
  
  package_rd <- package_rd(package)
  
  for (i in seq_along(topics)) {
    message("Generating ", basename(paths[[i]]))
    
    rd <- package_rd[[files_in[i]]]
    html <- to_html(rd, 
      env = new.env(parent = globalenv()), 
      base_path = base_path, 
      topic = str_replace(basename(paths[[i]]), "\\.html$", ""),
      examples = examples,
      package = package,
      index = index)

    html$package <- package_info
    render_template("topic", html, paths[[i]])
    graphics.off()

    all_topics <- index$file_out == files_out[i]
    if ("internal" %in% html$keywords) {
      index$class[all_topics] <- "internal"
    }
    index$title[all_topics] <- html$title
  }
  
  invisible(unname(apply(index, 1, as.list)))
}

readme <- function(package) {
  package <- as.package(package)
  path <- file.path(package$path, "README.md")
  if (!file.exists(path)) return()
  
  (markdownToHTML(path))
}

copy_bootstrap <- function(base_path) {
  bootstrap <- file.path(inst_path(), "bootstrap")
  file.copy(dir(bootstrap, full.names = TRUE), base_path, recursive = TRUE)
}

topic_index <- function(package) {
  message("Building package index")
  package <- as.package(package)
  
  rd <- package_rd(package)
  aliases <- lapply(rd, extract_alias)
  
  file_in <- rep(names(aliases), vapply(aliases, length, integer(1)))
  file_out <- str_replace(file_in, "\\.Rd$", ".html")
  
  data.frame(
    alias = unlist(aliases, use.names = FALSE),
    file_in = file_in,
    file_out = file_out,
    stringsAsFactors = FALSE
  )
}

extract_alias <- function(x) {
  tags <- vapply(x, tag, FUN.VALUE = character(1))
  to_html(x[tags == "alias"])
}

#' Return information about a package
#'
#' @param package name of package, as character vector
#' @return A named list of useful metadata about a package
#' @export
#' @keywords internal
#' @importFrom devtools as.package
package_info <- function(package) {
  out <- as.package(package)

  if (!is.null(out$url)) {
    out$urls <- str_trim(str_split(out$url, ",")[[1]])
    out$url <- NULL
  }
  # Dependencies 
  parse_deps <- devtools:::parse_deps
  out$dependencies <- list(
    depends = str_c(parse_deps(out$depends), collapse = ", "),
    imports = str_c(parse_deps(out$imports), collapse = ", "),
    suggests = str_c(parse_deps(out$suggests), collapse = ", "),
    extends = str_c(parse_deps(out$extends), collapse = ", ")
  )

  out
}

#' List all package vignettes.
#'
#' Copies all vignettes and returns data structure suitable for use with
#' whisker templates.
#'
#' @inheritParams build_package
#' @return a list, with one element for each vignette containing the vignette
#'   title and file name.
#' @export
build_vignettes <- function(package, base_path) {
  package <- as.package(package)
  
  # Locate source and built versions of vignettes
  path <- dir(file.path(package$path, c("inst/doc", "vignettes")), ".Rnw", 
    full.names = TRUE)
  if (length(path) == 0) return()
    
  message("Copying vignettes")
  filename <- str_replace(basename(path), "\\.Rnw$", ".pdf")
  src <- file.path(package$path, "inst/doc", filename)
  dest <- file.path(base_path, "vignettes")

  if (!file.exists(dest)) dir.create(dest)
  file.copy(src, file.path(dest, filename))  

  # Extract titles
  title <- vapply(path, FUN.VALUE = character(1), function(x) {
    contents <- str_c(readLines(x), collapse = "\n")
    str_match(contents, "\\\\VignetteIndexEntry\\{(.*?)\\}")[2]
  })  
  
  unname(apply(cbind(filename, title), 1, as.list))
}


build_demos <- function(package, base_path, info, index) {
  package <- as.package(package)

  demo_dir <- file.path(package$path, "demo")
  if (!file.exists(demo_dir)) return()
  
  message("Rendering demos")
  demos <- readLines(file.path(demo_dir, "00Index"))
  
  pieces <- str_split_fixed(demos, "\\s+", 2)
  in_path <- str_c(pieces[, 1], ".r")
  out_path <- str_c("demo-", pieces[,1], ".html")
  title <- pieces[, 2]
  
  for(i in seq_along(title)) {
    demo_code <- readLines(file.path(demo_dir, in_path[i]))
    demo_expr <- evaluate(demo_code, new.env(parent = globalenv()))

    info$demo <- replay_html(demo_expr, base_path = base_path, 
      name = str_c(pieces[i], "-"), index = index)
    info$title <- title[i]
    render_template("demo", info, file.path(base_path, out_path[i]))
  }
  
  unname(apply(cbind(out_path, title), 1, as.list))
}

